<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pole Spec Updater</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
<style>
  :root {
    --bg: #0b0d10; --panel: #12161b; --card: #161b22; --muted: #9aa4b2; --text: #e6edf3;
    --accent: #3b82f6; --accent-2: #10b981; --danger: #ef4444; --border: #263042;
    --radius: 14px; --shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  html,body { height: 100%; background: var(--bg); color: var(--text);
    font: 14px/1.45 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
  .container { max-width: 1100px; margin: 40px auto; padding: 0 20px; }
  .brand { display: flex; align-items: center; gap: 14px; margin-bottom: 24px; }
  .brand .logo { width: 40px; height: 40px; background: linear-gradient(135deg, var(--accent), #7c3aed);
    border-radius: 10px; box-shadow: var(--shadow); }
  h1 { font-size: 26px; margin: 0; letter-spacing: .2px; }
  .sub { color: var(--muted); margin: 4px 0 0; }
  .panel { background: linear-gradient(180deg, var(--panel), #0f141a); border: 1px solid var(--border);
    border-radius: var(--radius); box-shadow: var(--shadow); overflow: hidden; padding: 18px; }
  .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
  @media (max-width: 900px){ .grid{grid-template-columns: 1fr;} }
  .card { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 18px; }
  .card h3 { margin: 0 0 10px; font-size: 16px; }
  .filebox { border: 1px dashed #2b3647; border-radius: 10px; padding: 16px; display: grid; gap: 10px;
    background: #0f141a; transition: border-color .2s ease; }
  .file-row { display: flex; gap: 10px; align-items: center; }
  .file-row label { flex: 1; display: inline-flex; align-items: center; gap: 10px; background: #0e1319;
    border: 1px solid #1e2633; padding: 12px 14px; border-radius: 10px; cursor: pointer; }
  input[type=file] { display: none; }
  .hint { font-size: 12px; color: var(--muted); }
  .controls { display: flex; gap: 14px; align-items: center; margin-top: 10px; flex-wrap: wrap; }
  .slider { display: grid; gap: 6px; }
  .slider input[type=range] { width: 240px; }
  .btn { appearance: none; border: 0; background: linear-gradient(135deg, var(--accent), #7c3aed);
    color: white; padding: 12px 16px; border-radius: 12px; font-weight: 600; cursor: pointer;
    box-shadow: 0 6px 22px rgba(59,130,246,.35), inset 0 1px 0 rgba(255,255,255,.06);
    transition: transform .04s ease, filter .2s ease; }
  .btn:active { transform: translateY(1px); }
  .btn.secondary { background: #0f141a; border: 1px solid var(--border); color: #fff; box-shadow: none; }
  .btn[disabled] { opacity: .5; cursor: not-allowed; }
  .stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-top: 14px; }
  @media (max-width: 900px){ .stats{grid-template-columns: 1fr 1fr;} }
  .stat { background: #0f141a; border: 1px solid var(--border); padding: 12px; border-radius: 10px; }
  .stat b { display: block; font-size: 18px; margin-bottom: 3px; }
  .report { margin-top: 20px; }
  .accordion { display: grid; gap: 8px; }
  details.change { background: #0f141a; border: 1px solid var(--border); padding: 12px; border-radius: 10px; }
  details.change summary { cursor: pointer; list-style: none; }
  .chg { margin: 8px 0 0 0; padding-left: 6px; } .chg li { margin: 6px 0; }
  .pill { display: inline-block; padding: 4px 8px; border-radius: 999px; font-size: 12px;
    background: rgba(16,185,129,.15); border: 1px solid rgba(16,185,129,.35); color: #a7f3d0; }
  .pill.warn { background: rgba(239,68,68,.12); border-color: rgba(239,68,68,.35); color: #fecaca; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  .rules { color: var(--muted); font-size: 13px; margin-top: 6px; }
  footer { margin: 26px 0 60px; color: var(--muted); text-align: center; }
  .engine { display:flex; align-items:center; gap:10px; flex-wrap: wrap; margin-bottom: 10px; }
  .engine .status { padding: 6px 10px; border-radius: 999px; border:1px solid #2b3647; background:#0e1319; }
</style>
</head>
<body>
  <div class="container">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>Pole Spec Updater</h1>
        <p class="sub">Match by location, update specs, and export only the poles that changed — clean and auditable.</p>
      </div>
    </div>

    <div class="panel">
      <div class="grid">
        <div class="card">
          <h3>0) Excel Engine</h3>
          <div class="engine">
            <span id="engineStatus" class="status">Engine: <span class="mono">not loaded</span></span>
            <label for="engineFile" class="btn secondary">Load Excel Engine (.js)</label>
            <input id="engineFile" type="file" accept=".js" />
          </div>
          <div class="hint" style="margin-top:-6px; margin-bottom:12px;">
            Works offline. Place <span class="mono">xlsx.full.min.js</span> next to this HTML, or click “Load Excel Engine (.js)” to pick it from disk.
          </div>

          <h3>1) Upload spreadsheets</h3>
          <div id="drop" class="filebox">
            <div class="file-row">
              <label for="file1"><strong>Katapult Project Management Admin Report</strong> <span id="name1" class="hint">e.g., <em>BTX-Alice-PT3 test Node Attributes XLSX.xlsx</em></span></label>
              <input id="file1" type="file" accept=".xlsx,.xlsb,.xlsm,.xls" />
            </div>
            <div class="file-row">
              <label for="file2"><strong>Pole Map area selection</strong> <span id="name2" class="hint">e.g., <em>poles_selection_2025-10-09-11-47-52.xlsx</em></span></label>
              <input id="file2" type="file" accept=".xlsx,.xlsb,.xlsm,.xls" />
            </div>
            <div class="rules">
              <ul>
                <li>Smart geo‑matching (Haversine) within a configurable radius (default <b>2&nbsp;m</b>).</li>
                <li>Updates <span class="mono">pole_height</span>, <span class="mono">pole_class</span>, <span class="mono">pole_spec</span>, <span class="mono">proposed_pole_spec</span>, and
                  <span class="mono">brownsville public utilities_tag</span> (or <span class="mono">text pole_tag</span> if BPU tag not present).</li>
                <li>“Southern Pine” casing is preserved to match the first sheet.</li>
                <li>Export includes only poles that changed and <em>omits</em> the following columns:
                  <span class="mono">feedback</span>, <span class="mono">pole_owner</span>, <span class="mono">brownsville public utilities_tag</span>,
                  <span class="mono">make_ready_notes</span>, <span class="mono">time_bucket_start</span>, <span class="mono">time_bucket_stop</span>,
                  <span class="mono">time_bucket_user</span>, <span class="mono">photo_count</span>, <span class="mono">main_photo</span>, <span class="mono">all_photos</span>.
                  No Change Log sheet is added to the export.</li>
              </ul>
            </div>
          </div>
          <div class="controls">
            <div class="slider">
              <label for="threshold">Match radius: <b><span id="thLabel">2</span> m</b></label>
              <input id="threshold" type="range" min="1" max="40" step="1" value="2" />
            </div>
            <button id="process" class="btn" disabled>Process & Generate Report</button>
            <button id="download" class="btn secondary" disabled>Download Updated Spreadsheet</button>
          </div>
          <div class="stats" id="stats" hidden>
            <div class="stat"><b id="s1">0</b><span class="hint">Poles (node_type matches)</span></div>
            <div class="stat"><b id="s2">0</b><span class="hint">Second‑sheet candidates</span></div>
            <div class="stat"><b id="s3">0</b><span class="hint">Geo‑matches</span></div>
            <div class="stat"><b id="s4">0</b><span class="hint">Rows updated & kept</span></div>
          </div>
        </div>

        <div class="card">
          <h3>2) Change report</h3>
          <div id="reportIntro" class="hint">Audit log ordered by <span class="mono">scid</span> (leading zeros preserved). (No log sheet is added to the download.)</div>
          <div class="report" id="report"></div>
        </div>
      </div>
    </div>

    <footer>© Pole Spec Updater — designed for clarity, traceability, and safety.</footer>
  </div>

  <script>
  (function(){
    const $ = sel => document.querySelector(sel);

    // ---------- Excel engine loader (offline-first) ----------
    const engineStatus = $('#engineStatus');
    const engineFile = $('#engineFile');
    const processBtn = $('#process');
    const downloadBtn = $('#download');

    let engineReady = false;
    function setEngineStatus(ok, source) {
      engineReady = !!ok;
      engineStatus.innerHTML = ok
        ? `Engine: <span class="mono">loaded</span> <span class="pill">${source}</span>`
        : `Engine: <span class="mono">not loaded</span>`;
      maybeEnableProcess();
    }
    function loadScript(url){
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = url; s.async = true;
        s.onload = () => resolve(url);
        s.onerror = () => reject(new Error("Failed to load "+url));
        document.head.appendChild(s);
      });
    }
    async function ensureXLSX(){
      if (window.XLSX) { setEngineStatus(true, 'preloaded'); return; }
      const local = ["./xlsx.full.min.js","./libs/xlsx.full.min.js"];
      const cdns  = [
        "https://cdn.jsdelivr.net/npm/xlsx@0.20.2/dist/xlsx.full.min.js",
        "https://unpkg.com/xlsx@0.20.2/dist/xlsx.full.min.js",
        "https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.20.2/xlsx.full.min.js"
      ];
      for (const u of local) { try { await loadScript(u); if (window.XLSX) { setEngineStatus(true, 'local'); return; } } catch(_) {} }
      for (const u of cdns)  { try { await loadScript(u); if (window.XLSX) { setEngineStatus(true, 'CDN');  return; } } catch(_) {} }
      setEngineStatus(false);
    }
    engineFile.addEventListener('change', e => {
      const f = e.target.files && e.target.files[0]; if (!f) return;
      const url = URL.createObjectURL(f);
      loadScript(url).then(() => {
        URL.revokeObjectURL(url);
        if (window.XLSX) setEngineStatus(true, 'manual upload'); else setEngineStatus(false);
      }).catch(err => { URL.revokeObjectURL(url); setEngineStatus(false); toast(err.message || String(err), true); });
    });
    ensureXLSX();

    // ---------- App state ----------
    const file1 = $('#file1'), file2 = $('#file2');
    const name1 = $('#name1'), name2 = $('#name2');
    const reportEl = $('#report'), reportIntro = $('#reportIntro');
    const statsBox = $('#stats'); const s1=$('#s1'), s2=$('#s2'), s3=$('#s3'), s4=$('#s4');
    const th=$('#threshold'), thLabel=$('#thLabel'); th.addEventListener('input', () => thLabel.textContent = th.value);

    let wb1, wb2, parsedFirst, parsedSecond, headerFirst, headerSecond, outputWb;

    const drop = $('#drop');
    ;['dragover','dragenter'].forEach(ev => drop.addEventListener(ev, e => { e.preventDefault(); drop.classList.add('drag'); }));
    ;['dragleave','drop'].forEach(ev => drop.addEventListener(ev, e => { e.preventDefault(); drop.classList.remove('drag'); }));
    drop.addEventListener('drop', e => {
      const items = [...e.dataTransfer.files];
      if (!items.length) return;
      const f1 = items.find(f => /katapult|admin|brownsville|node attributes|btx/i.test(f.name)) || items[0];
      const f2 = items.find(f => /pole|selection|map/i.test(f.name)) || items.find(f => f !== f1);
      if (f1) { assignFile(file1, f1); }
      if (f2) { assignFile(file2, f2); }
    });

    file1.addEventListener('change', e => assignFile(file1, e.target.files[0]));
    file2.addEventListener('change', e => assignFile(file2, e.target.files[0]));

    function assignFile(input, file) {
      if (!file) return;
      if (input === file1) name1.innerHTML = `<span class="pill">${escapeHtml(file.name)}</span>`;
      if (input === file2) name2.innerHTML = `<span class="pill">${escapeHtml(file.name)}</span>`;
      readWorkbook(file).then(wb => {
        if (input === file1) wb1 = wb; else wb2 = wb;
        maybeEnableProcess();
      }).catch(err => toast(err.message || String(err), true));
    }

    function maybeEnableProcess(){
      processBtn.disabled = !(engineReady && wb1 && wb2);
      downloadBtn.disabled = !outputWb;
    }

    processBtn.addEventListener('click', async () => {
      if (!window.XLSX) { toast("Excel engine not loaded.", true); return; }
      disableAll(true);
      try {
        const tMeters = Number(th.value);
        const { table: table1, header: h1 } = pickAndParseSheet(wb1, /*isFirst=*/true);
        const { table: table2, header: h2 } = pickAndParseSheet(wb2, /*isFirst=*/false);
        parsedFirst = table1; headerFirst = h1;
        parsedSecond = table2; headerSecond = h2;

        const result = runUpdater(parsedFirst, headerFirst, parsedSecond, headerSecond, tMeters);
        const { updatedRows, changeLog, keptCount, poleCount, candCount, matchCount, headersOut } = result;

        outputWb = buildWorkbook(headersOut, updatedRows /*, changeLog */);

        s1.textContent = poleCount.toLocaleString();
        s2.textContent = candCount.toLocaleString();
        s3.textContent = matchCount.toLocaleString();
        s4.textContent = keptCount.toLocaleString();
        statsBox.hidden = false;

        renderReport(changeLog);

        downloadBtn.disabled = keptCount === 0;
        reportIntro.style.display = 'none';
        toast(keptCount ? `Finished: ${keptCount} pole${keptCount===1?'':'s'} updated.` : 'Finished: no changes needed.');
      } catch (err) {
        console.error(err);
        toast(err.message || String(err), true);
      } finally {
        disableAll(false);
      }
    });

    downloadBtn.addEventListener('click', () => {
      if (!outputWb) return;
      const base = (file1.files?.[0]?.name || 'Admin_Report').replace(/\.[^.]+$/, '');
      const fname = `${base}-UPDATED.xlsx`;
      XLSX.writeFile(outputWb, fname);
    });

    function disableAll(disabled) {
      processBtn.disabled = disabled || !(engineReady && wb1 && wb2);
      downloadBtn.disabled = disabled || !outputWb;
      file1.disabled = disabled; file2.disabled = disabled; th.disabled = disabled;
      engineFile.disabled = disabled;
    }

    function toast(msg, isErr=false) {
      const el = document.createElement('div');
      el.textContent = msg;
      el.style.position = 'fixed'; el.style.right = '18px'; el.style.bottom = '18px';
      el.style.background = isErr ? 'rgba(239,68,68,.95)' : 'rgba(16,185,129,.95)';
      el.style.color = '#fff'; el.style.padding = '10px 14px'; el.style.borderRadius = '10px';
      el.style.boxShadow = '0 8px 22px rgba(0,0,0,.35)'; el.style.zIndex = 9999;
      document.body.appendChild(el); setTimeout(() => el.remove(), 3800);
    }

    // ---------- Core helpers ----------
    function readWorkbook(file) {
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = e => {
          try {
            const data = new Uint8Array(e.target.result);
            const wb = XLSX.read(data, { type: 'array' });
            resolve(wb);
          } catch (err) { reject(err); }
        };
        fr.onerror = () => reject(fr.error || new Error('Failed to read file'));
        fr.readAsArrayBuffer(file);
      });
    }

    function normalizeKey(k) { return String(k || '').toLowerCase().replace(/[^a-z0-9]/g, ''); }

    const KEYSETS = {
      lat: ['latitude','lat','y','latdd','lat_deg','lat_dec'],
      lon: ['longitude','lon','lng','x','londd','long','lon_deg','lon_dec'],
      nodeType: ['node_type','nodetype','node type','assettype','type'],
      scid: ['scid','sc id','sc_id'],
      poleSpec: ['pole_spec','polespec'],
      proposedPoleSpec: ['proposed_pole_spec','proposedpolespec','proposed pole spec'],
      poleClass: ['pole_class','poleclass','class'],
      poleHeight: ['pole_height','poleheight','height'],
      // Prefer Brownsville tag when present; fall back to text pole_tag / variants
      bpuTag: ['brownsville public utilities_tag','brownsville public utilities tag','bpu tag','bpu_tag'],
      textPoleTag: ['text pole_tag','textpoletag','poletag','pole_tag','pole tag','tag','texttag'],
      fieldTag: ['field_tag','fieldtag','tag','pole_tag','poletag']
    };

    /** Columns to remove from the exported Excel file (case/spacing-insensitive). */
    const DROP_COLS = [
      'feedback',
      'pole_owner',
      'brownsville public utilities_tag',
      'make_ready_notes',
      'time_bucket_start',
      'time_bucket_stop',
      'time_bucket_user',
      'photo_count',
      'main_photo',
      'all_photos'
    ];

    function findHeaderKey(headerRow, keyset) {
      const cand = keyset.map(normalizeKey);
      const normMap = new Map(headerRow.map(h => [normalizeKey(h), h]));
      for (const n of cand) if (normMap.has(n)) return normMap.get(n);
      for (const h of headerRow) { const hn = normalizeKey(h); if (cand.some(n => hn.includes(n))) return h; }
      return null;
    }

    function pickAndParseSheet(workbook, isFirst) {
      let bestSheetName = workbook.SheetNames[0];
      let bestScore = -1;
      for (const name of workbook.SheetNames) {
        const ws = workbook.Sheets[name];
        const rows = XLSX.utils.sheet_to_json(ws, { header: 1, raw: false, defval: '' });
        if (!rows.length) continue;
        const header = rows[0].map(v => String(v || ''));
        const score = scoreHeader(header, isFirst);
        if (score > bestScore) { bestScore = score; bestSheetName = name; }
      }
      const ws = workbook.Sheets[bestSheetName];
      const rows = XLSX.utils.sheet_to_json(ws, { header: 1, raw: false, defval: '' });
      const header = rows[0].map(v => String(v || ''));
      const dataRows = rows.slice(1);
      const table = dataRows.map(r => { const obj = {}; header.forEach((h, i) => obj[h] = r[i] ?? ''); return obj; });
      return { header, table, sheetName: bestSheetName };
    }

    function scoreHeader(headerRow, isFirst) {
      const need = isFirst ? [KEYSETS.lat, KEYSETS.lon] : [KEYSETS.lat, KEYSETS.lon, KEYSETS.fieldTag];
      let sc = 0;
      for (const ks of need) if (findHeaderKey(headerRow, ks)) sc += 2;
      if (isFirst && findHeaderKey(headerRow, KEYSETS.scid)) sc += 1;
      if (findHeaderKey(headerRow, KEYSETS.nodeType)) sc += 1;
      return sc;
    }

    function parseNumber(v) {
      if (v === null || v === undefined) return null;
      const s = String(v).trim(); if (!s) return null;
      const num = Number(s.replace(/[^0-9.+-]/g, ''));
      return Number.isFinite(num) ? num : null;
    }

    function deg2rad(d){ return d*Math.PI/180; }
    function haversineMeters(lat1, lon1, lat2, lon2) {
      if ([lat1,lon1,lat2,lon2].some(v => !Number.isFinite(v))) return Number.POSITIVE_INFINITY;
      const R = 6371000;
      const dLat = deg2rad(lat2 - lat1), dLon = deg2rad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(deg2rad(lat1))*Math.cos(deg2rad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a));
    }

    // ----- SOUTHERN PINE casing preservation -----
    function extractPineCase(str){
      const m = String(str || '').match(/southern\s+pine/i);
      return m ? m[0] : null; // returns the exact case from the match
    }
    function detectGlobalPineStyle(rows, poleSpecKey, proposedSpecKey){
      const counts = new Map();
      const add = (s) => { const v = extractPineCase(s); if (v) counts.set(v, (counts.get(v)||0)+1); };
      for (const r of rows) {
        if (poleSpecKey) add(r[poleSpecKey]);
        if (proposedSpecKey) add(r[proposedSpecKey]);
      }
      if (!counts.size) return 'SOUTHERN PINE';
      let best='', n=-1;
      for (const [style,c] of counts.entries()) { if (c>n || (c===n && style==='SOUTHERN PINE')) { best=style; n=c; } }
      return best || 'SOUTHERN PINE';
    }

    function parsePoleSpec(specStr) {
      const s = String(specStr || '');
      const m = s.match(/(\d+)\s*-\s*([A-Za-z0-9]+)\s+southern\s+pine/i);
      if (!m) return null;
      return { height: parseInt(m[1], 10), cls: m[2] };
    }
    function makePoleSpec(height, cls, pineLabel) {
      if (height == null || cls == null || cls === '') return null;
      const h = String(height).trim();
      const c = String(cls).trim().toUpperCase();
      return `${h}-${c} ${pineLabel || 'SOUTHERN PINE'}`;
    }

    function safeVal(v) { if (v===null||v===undefined) return ''; return typeof v==='number'? v : String(v); }
    function cloneRow(row){ const o={}; for (const k of Object.keys(row)) o[k]=row[k]; return o; }

    function parseCoords(row, header) {
      const latKey = findHeaderKey(header, KEYSETS.lat);
      const lonKey = findHeaderKey(header, KEYSETS.lon);
      const lat = parseNumber(row[latKey]);
      const lon = parseNumber(row[lonKey]);
      return { lat, lon, latKey, lonKey };
    }

    function isPoleRow(row, header) {
      const nodeKey = findHeaderKey(header, KEYSETS.nodeType);
      if (!nodeKey) return true;
      const v = String(row[nodeKey] ?? '').toLowerCase();
      return v.includes('pole');
    }

    function runUpdater(firstRows, firstHeader, secondRows, secondHeader, thresholdMeters) {
      const scidKey = findHeaderKey(firstHeader, KEYSETS.scid);
      const bpuTagKey = findHeaderKey(firstHeader, KEYSETS.bpuTag);
      const fallbackTextTagKey = findHeaderKey(firstHeader, KEYSETS.textPoleTag) || findHeaderKey(firstHeader, ['poletag']);
      const firstTagKey = bpuTagKey || fallbackTextTagKey; // prefer Brownsville tag when present
      const secondTagKey = findHeaderKey(secondHeader, KEYSETS.fieldTag);

      let poleClassKey1 = findHeaderKey(firstHeader, KEYSETS.poleClass);
      let poleHeightKey1 = findHeaderKey(firstHeader, KEYSETS.poleHeight);
      let poleSpecKey1 = findHeaderKey(firstHeader, KEYSETS.poleSpec);
      const proposedSpecKey1 = findHeaderKey(firstHeader, KEYSETS.proposedPoleSpec);

      const poleClassKey2 = findHeaderKey(secondHeader, KEYSETS.poleClass);
      const poleHeightKey2 = findHeaderKey(secondHeader, KEYSETS.poleHeight);

      const firstFiltered = firstRows.filter(r => isPoleRow(r, firstHeader));
      const secondFiltered = secondRows.filter(r => {
        if (!isPoleRow(r, secondHeader)) return false;
        const {lat,lon} = parseCoords(r, secondHeader);
        return Number.isFinite(lat) && Number.isFinite(lon);
      });

      const secondWithCoords = secondFiltered.map(r => {
        const {lat, lon} = parseCoords(r, secondHeader);
        return { r, lat, lon };
      });

      // Precompute global preferred "Southern Pine" casing for this sheet
      const pineGlobal = detectGlobalPineStyle(firstRows, poleSpecKey1, proposedSpecKey1);

      const matches = new Map();
      let matchCount = 0;

      for (let i = 0; i < firstFiltered.length; i++) {
        const fr = firstFiltered[i];
        const {lat: lat1, lon: lon1} = parseCoords(fr, firstHeader);
        if (!Number.isFinite(lat1) || !Number.isFinite(lon1)) continue;

        const latTol = thresholdMeters / 110540;
        const lonTol = thresholdMeters / (111320 * Math.max(0.3, Math.cos(deg2rad(lat1))));
        const candidates = secondWithCoords.filter(p => Math.abs(p.lat - lat1) <= latTol*3 && Math.abs(p.lon - lon1) <= lonTol*3);

        let best = null, bestD = Infinity;
        for (const c of candidates) {
          const d = haversineMeters(lat1, lon1, c.lat, c.lon);
          if (d < bestD) { bestD = d; best = c; }
        }
        if (best && bestD <= thresholdMeters) {
          matches.set(i, { candidate: best, dist: bestD });
          matchCount++;
        }
      }

      const headersOut = firstHeader.slice();
      const missingToAppend = [];
      if (!poleClassKey1) { poleClassKey1 = 'pole_class'; if (!headersOut.includes(poleClassKey1)) missingToAppend.push(poleClassKey1); }
      if (!poleHeightKey1) { poleHeightKey1 = 'pole_height'; if (!headersOut.includes(poleHeightKey1)) missingToAppend.push(poleHeightKey1); }
      if (!poleSpecKey1 && !headersOut.includes('pole_spec')) { poleSpecKey1 = 'pole_spec'; headersOut.push('pole_spec'); }
      for (const h of missingToAppend) headersOut.push(h);

      const updatedRows = [];
      const changeLog = [];

      for (let i = 0; i < firstFiltered.length; i++) {
        const fr = firstFiltered[i];
        const match = matches.get(i);
        if (!match) continue;

        const original = cloneRow(fr);
        const updated = cloneRow(fr);
        const changes = [];
        const sr = match.candidate.r;

        const secondHeight = poleHeightKey2 ? safeVal(sr[poleHeightKey2]).toString().trim() : '';
        const secondClass  = poleClassKey2 ? safeVal(sr[poleClassKey2]).toString().trim() : '';
        const firstHeight  = poleHeightKey1 ? safeVal(updated[poleHeightKey1]).toString().trim() : '';
        const firstClass   = poleClassKey1 ? safeVal(updated[poleClassKey1]).toString().trim() : '';

        if (secondHeight) {
          if (firstHeight !== secondHeight) {
            updated[poleHeightKey1] = secondHeight;
            changes.push(`pole_height: ${firstHeight||'∅'} → ${secondHeight}`);
          }
        }
        if (secondClass) {
          if (firstClass !== secondClass) {
            updated[poleClassKey1] = secondClass;
            changes.push(`pole_class: ${firstClass||'∅'} → ${secondClass}`);
          }
        }

        const oldSpecStr = poleSpecKey1 ? safeVal(original[poleSpecKey1]) : '';
        const oldSpec = parsePoleSpec(oldSpecStr) || { height: parseNumber(firstHeight), cls: firstClass || null };
        const newHeightNum = parseNumber(secondHeight) ?? oldSpec.height ?? parseNumber(firstHeight);
        const newClassStr  = (secondClass || oldSpec.cls || firstClass || '').toString().trim();

        // Choose "Southern Pine" label: use row style if present, else global
        const pineLabelForRow = extractPineCase(oldSpecStr) || pineGlobal;

        if (newHeightNum && newClassStr) {
          const newSpecStr = makePoleSpec(newHeightNum, newClassStr, pineLabelForRow);
          const currentSpecStr = poleSpecKey1 ? safeVal(updated[poleSpecKey1]) : '';
          if (!currentSpecStr || currentSpecStr !== newSpecStr) {
            updated[poleSpecKey1] = newSpecStr;
            changes.push(`pole_spec: ${oldSpecStr||'∅'} → ${newSpecStr}`);

            if (proposedSpecKey1) {
              const oldPropStr = safeVal(original[proposedSpecKey1]);
              const oldProp = parsePoleSpec(oldPropStr);
              if (oldProp && oldSpec && Number(oldProp.height) === Number(oldSpec.height)) {
                if (safeVal(updated[proposedSpecKey1])) {
                  updated[proposedSpecKey1] = '';
                  changes.push(`proposed_pole_spec: ${oldPropStr} → (removed)`);
                }
              } else if (oldPropStr) {
                const propHeight = Number(newHeightNum) + 5;
                const newPropStr = makePoleSpec(propHeight, newClassStr, pineLabelForRow);
                if (newPropStr && oldPropStr !== newPropStr) {
                  updated[proposedSpecKey1] = newPropStr;
                  changes.push(`proposed_pole_spec: ${oldPropStr} → ${newPropStr}`);
                }
              }
            }
          }
        }

        // Tag update: prefer Brownsville Public Utilities tag column when present
        if (firstTagKey && secondTagKey) {
          const oldTag = String(safeVal(original[firstTagKey])).trim();
          const newTag = String(safeVal(sr[secondTagKey])).trim();
          if (newTag && oldTag !== newTag) {
            updated[firstTagKey] = newTag;
            // Show the exact column name in the change log for clarity
            changes.push(`${firstTagKey}: ${oldTag || '∅'} → ${newTag}`);
          }
        }

        if (changes.length) {
          updatedRows.push(updated);
          const scidStr = scidKey ? safeVal(original[scidKey]).toString() : '(no scid)';
          const scidNum = parseInt(scidStr.replace(/\D/g,''), 10);
          const { lat: fLat, lon: fLon } = parseCoords(original, firstHeader);
          const { lat: sLat, lon: sLon } = parseCoords(sr, secondHeader);
          changeLog.push({
            scidStr, scidNum: Number.isFinite(scidNum) ? scidNum : Number.MAX_SAFE_INTEGER,
            distance: Math.round(match.dist),
            changes,
            coords: { fLat, fLon, sLat, sLon }
          });
        }
      }

      changeLog.sort((a,b) => a.scidNum - b.scidNum);

      return {
        updatedRows,
        changeLog,
        keptCount: updatedRows.length,
        poleCount: firstFiltered.length,
        candCount: secondFiltered.length,
        matchCount,
        headersOut
      };
    }

    // Build workbook: remove unwanted columns and DO NOT add a log sheet
    function buildWorkbook(headersOut, rowsOut /* , changeLog */) {
      const dropSet = new Set(DROP_COLS.map(normalizeKey));
      const finalHeaders = headersOut.filter(h => !dropSet.has(normalizeKey(h)));

      const wb = XLSX.utils.book_new();
      const aoa = [finalHeaders.slice()];
      for (const r of rowsOut) {
        aoa.push(finalHeaders.map(h => r[h] ?? ''));
      }
      const ws1 = XLSX.utils.aoa_to_sheet(aoa);
      XLSX.utils.book_append_sheet(wb, ws1, 'Updated Poles');

      // No Change Log sheet per requirement
      return wb;
    }

    function renderReport(changeLog) {
      if (!changeLog.length) {
        reportEl.innerHTML = `<div class="hint">No changes were necessary at the current match radius.</div>`;
        return;
      }
      const frag = document.createDocumentFragment();
      const container = document.createElement('div'); container.className = 'accordion';

      for (const entry of changeLog) {
        const det = document.createElement('details'); det.className = 'change';
        const sum = document.createElement('summary');
        const id = escapeHtml(entry.scidStr || '(no scid)');

        // Badges: detect fields changed
        const cLower = entry.changes.map(c => c.toLowerCase());
        const hasTag    = cLower.some(c => c.includes('tag:')); // robust for "..._tag:"
        const hasSpec   = cLower.some(c => c.startsWith('pole_spec:'));
        const hasHeight = cLower.some(c => c.startsWith('pole_height:'));
        const hasClass  = cLower.some(c => c.startsWith('pole_class:'));
        const hasProp   = cLower.some(c => c.startsWith('proposed_pole_spec:'));

        const badges = [
          hasTag    ? '<span class="pill">TAG</span>'       : '',
          hasSpec   ? '<span class="pill">SPEC</span>'      : '',
          hasHeight ? '<span class="pill">HEIGHT</span>'    : '',
          hasClass  ? '<span class="pill">CLASS</span>'     : '',
          hasProp   ? '<span class="pill">PROPOSED</span>'  : ''
        ].filter(Boolean).join(' ');

        sum.innerHTML = `<strong>SCID <span class="mono">${id}</span></strong> &nbsp; <span class="pill">${entry.distance} m</span> ${badges}`;
        det.appendChild(sum);

        const ul = document.createElement('ul'); ul.className = 'chg';
        for (const ch of entry.changes) {
          const li = document.createElement('li');
          li.innerHTML = escapeHtml(ch).replace(/ → /g, ' &rarr; ');
          ul.appendChild(li);
        }
        const meta = document.createElement('div');
        meta.className = 'hint'; meta.style.marginTop = '8px';
        meta.innerHTML = `
          Matched by coordinates within ${entry.distance} m.
          <span class="mono">[${fmt(entry.coords.fLat)}, ${fmt(entry.coords.fLon)}]</span> → 
          <span class="mono">[${fmt(entry.coords.sLat)}, ${fmt(entry.coords.sLon)}]</span>
        `;
        det.appendChild(ul); det.appendChild(meta);
        container.appendChild(det);
      }

      frag.appendChild(container);
      reportEl.innerHTML = '';
      reportEl.appendChild(frag);
    }

    function fmt(v){ return (v==null||v==='') ? '∅' : Number(v).toFixed(6); }
    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  })();
  </script>
</body>
</html>
